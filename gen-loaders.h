/* This file is automatically generated with util/structgen */
void effect_scan_b_index(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_b_index_data *d = (void*)e->data;
	fread(&d->index, sizeof(int), 1, stream);
}
void effect_dump_b_index(effect_s *e, FILE *stream) {
	effect_b_index_data *d = (void*)e->data;
	fwrite(&d->index, sizeof(int), 1, stream);
}
void effect_scan_ph_block(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_ph_block_data *d = (void*)e->data;
	fread(&d->x, sizeof(int), 1, stream);
	fread(&d->y, sizeof(int), 1, stream);
	fread(&d->z, sizeof(int), 1, stream);
	fread(&d->prop, sizeof(unsigned), 1, stream);
}
void effect_dump_ph_block(effect_s *e, FILE *stream) {
	effect_ph_block_data *d = (void*)e->data;
	fwrite(&d->x, sizeof(int), 1, stream);
	fwrite(&d->y, sizeof(int), 1, stream);
	fwrite(&d->z, sizeof(int), 1, stream);
	fwrite(&d->prop, sizeof(unsigned), 1, stream);
}
void effect_scan_ph_item(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_ph_item_data *d = (void*)e->data;
	fread(&d->x, sizeof(int), 1, stream);
	fread(&d->y, sizeof(int), 1, stream);
	fread(&d->z, sizeof(int), 1, stream);
	fread(&d->weight, sizeof(int), 1, stream);
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->parent = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->parent = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->parent = ENT_NULL; }
	else {d->parent = ENT_NULL;} }
	fread(&d->parent_type, sizeof(parent_ref_type), 1, stream);
}
void effect_dump_ph_item(effect_s *e, FILE *stream) {
	effect_ph_item_data *d = (void*)e->data;
	fwrite(&d->x, sizeof(int), 1, stream);
	fwrite(&d->y, sizeof(int), 1, stream);
	fwrite(&d->z, sizeof(int), 1, stream);
	fwrite(&d->weight, sizeof(int), 1, stream);
	{ int t; if (d->parent == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->parent) != NULL) {t = entity_get_index(ent_aptr(d->parent));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->parent, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
	fwrite(&d->parent_type, sizeof(parent_ref_type), 1, stream);
}
void effect_scan_tracer(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_tracer_data *d = (void*)e->data;
	fread(&d->x, sizeof(int), 1, stream);
	fread(&d->y, sizeof(int), 1, stream);
	fread(&d->z, sizeof(int), 1, stream);
	fread(&d->cur_x, sizeof(int), 1, stream);
	fread(&d->cur_y, sizeof(int), 1, stream);
	fread(&d->cur_z, sizeof(int), 1, stream);
	fread(&d->speed, sizeof(int), 1, stream);
}
void effect_dump_tracer(effect_s *e, FILE *stream) {
	effect_tracer_data *d = (void*)e->data;
	fwrite(&d->x, sizeof(int), 1, stream);
	fwrite(&d->y, sizeof(int), 1, stream);
	fwrite(&d->z, sizeof(int), 1, stream);
	fwrite(&d->cur_x, sizeof(int), 1, stream);
	fwrite(&d->cur_y, sizeof(int), 1, stream);
	fwrite(&d->cur_z, sizeof(int), 1, stream);
	fwrite(&d->speed, sizeof(int), 1, stream);
}
void effect_scan_block_move(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_block_move_data *d = (void*)e->data;
	fread(&d->x, sizeof(int), 1, stream);
	fread(&d->y, sizeof(int), 1, stream);
	fread(&d->z, sizeof(int), 1, stream);
	fread(&d->delay, sizeof(int), 1, stream);
}
void effect_dump_block_move(effect_s *e, FILE *stream) {
	effect_block_move_data *d = (void*)e->data;
	fwrite(&d->x, sizeof(int), 1, stream);
	fwrite(&d->y, sizeof(int), 1, stream);
	fwrite(&d->z, sizeof(int), 1, stream);
	fwrite(&d->delay, sizeof(int), 1, stream);
}
void effect_scan_stair_move(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_stair_move_data *d = (void*)e->data;
	fread(&d->dir, sizeof(int), 1, stream);
	fread(&d->delay, sizeof(int), 1, stream);
}
void effect_dump_stair_move(effect_s *e, FILE *stream) {
	effect_stair_move_data *d = (void*)e->data;
	fwrite(&d->dir, sizeof(int), 1, stream);
	fwrite(&d->delay, sizeof(int), 1, stream);
}
void effect_scan_render(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_render_data *d = (void*)e->data;
	fread(&d->chr, sizeof(char), 1, stream);
	fread(&d->r, sizeof(uint8_t), 1, stream);
	fread(&d->g, sizeof(uint8_t), 1, stream);
	fread(&d->b, sizeof(uint8_t), 1, stream);
	fread(&d->a, sizeof(uint8_t), 1, stream);
}
void effect_dump_render(effect_s *e, FILE *stream) {
	effect_render_data *d = (void*)e->data;
	fwrite(&d->chr, sizeof(char), 1, stream);
	fwrite(&d->r, sizeof(uint8_t), 1, stream);
	fwrite(&d->g, sizeof(uint8_t), 1, stream);
	fwrite(&d->b, sizeof(uint8_t), 1, stream);
	fwrite(&d->a, sizeof(uint8_t), 1, stream);
}
void effect_scan_limb_slot(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_limb_slot_data *d = (void*)e->data;
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->item = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->item = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->item = ENT_NULL; }
	else {d->item = ENT_NULL;} }
	fread(&d->tag, sizeof(uint32_t), 1, stream);
}
void effect_dump_limb_slot(effect_s *e, FILE *stream) {
	effect_limb_slot_data *d = (void*)e->data;
	{ int t; if (d->item == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->item) != NULL) {t = entity_get_index(ent_aptr(d->item));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->item, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
	fwrite(&d->tag, sizeof(uint32_t), 1, stream);
}
int effect_rem_limb_slot(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_limb_slot_data *d = (void*)e->data;
	if (d->item != ENT_NULL && entity_has_effect(d->item, EF_B_NONEXISTENT)) d->item = ENT_NULL;
	return 0;
}
void effect_scan_limb_hand(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_limb_hand_data *d = (void*)e->data;
	fread(&d->grab_type, sizeof(int), 1, stream);
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->item = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->item = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->item = ENT_NULL; }
	else {d->item = ENT_NULL;} }
}
void effect_dump_limb_hand(effect_s *e, FILE *stream) {
	effect_limb_hand_data *d = (void*)e->data;
	fwrite(&d->grab_type, sizeof(int), 1, stream);
	{ int t; if (d->item == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->item) != NULL) {t = entity_get_index(ent_aptr(d->item));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->item, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
}
int effect_rem_limb_hand(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_limb_hand_data *d = (void*)e->data;
	if (d->item != ENT_NULL && entity_has_effect(d->item, EF_B_NONEXISTENT)) d->item = ENT_NULL;
	return 0;
}
void effect_scan_material(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_material_data *d = (void*)e->data;
	fread(&d->type, sizeof(material_type), 1, stream);
	fread(&d->dur, sizeof(int), 1, stream);
	fread(&d->prop, sizeof(uint32_t), 1, stream);
	fread(&d->tag, sizeof(uint32_t), 1, stream);
}
void effect_dump_material(effect_s *e, FILE *stream) {
	effect_material_data *d = (void*)e->data;
	fwrite(&d->type, sizeof(material_type), 1, stream);
	fwrite(&d->dur, sizeof(int), 1, stream);
	fwrite(&d->prop, sizeof(uint32_t), 1, stream);
	fwrite(&d->tag, sizeof(uint32_t), 1, stream);
}
void effect_scan_aim(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_aim_data *d = (void*)e->data;
	fread(&d->x, sizeof(int), 1, stream);
	fread(&d->y, sizeof(int), 1, stream);
	fread(&d->z, sizeof(int), 1, stream);
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->ent = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->ent = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->ent = ENT_NULL; }
	else {d->ent = ENT_NULL;} }
}
void effect_dump_aim(effect_s *e, FILE *stream) {
	effect_aim_data *d = (void*)e->data;
	fwrite(&d->x, sizeof(int), 1, stream);
	fwrite(&d->y, sizeof(int), 1, stream);
	fwrite(&d->z, sizeof(int), 1, stream);
	{ int t; if (d->ent == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->ent) != NULL) {t = entity_get_index(ent_aptr(d->ent));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->ent, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
}
int effect_rem_aim(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_aim_data *d = (void*)e->data;
	if (d->ent != ENT_NULL && entity_has_effect(d->ent, EF_B_NONEXISTENT)) d->ent = ENT_NULL;
	return 0;
}
void effect_scan_attack(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_attack_data *d = (void*)e->data;
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->ent = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->ent = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->ent = ENT_NULL; }
	else {d->ent = ENT_NULL;} }
	fread(&d->limb_tag, sizeof(uint32_t), 1, stream);
	fread(&d->type, sizeof(int), 1, stream);
	fread(&d->weapon_mat, sizeof(uint32_t), 1, stream);
	fread(&d->delay, sizeof(int), 1, stream);
}
void effect_dump_attack(effect_s *e, FILE *stream) {
	effect_attack_data *d = (void*)e->data;
	{ int t; if (d->ent == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->ent) != NULL) {t = entity_get_index(ent_aptr(d->ent));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->ent, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
	fwrite(&d->limb_tag, sizeof(uint32_t), 1, stream);
	fwrite(&d->type, sizeof(int), 1, stream);
	fwrite(&d->weapon_mat, sizeof(uint32_t), 1, stream);
	fwrite(&d->delay, sizeof(int), 1, stream);
}
int effect_rem_attack(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_attack_data *d = (void*)e->data;
	if (d->ent == ENT_NULL || entity_has_effect(d->ent, EF_B_NONEXISTENT)) return 1;
	return 0;
}
void effect_scan_table_item(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_table_item_data *d = (void*)e->data;
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->item = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->item = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->item = ENT_NULL; }
	else {d->item = ENT_NULL;} }
}
void effect_dump_table_item(effect_s *e, FILE *stream) {
	effect_table_item_data *d = (void*)e->data;
	{ int t; if (d->item == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->item) != NULL) {t = entity_get_index(ent_aptr(d->item));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->item, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
}
int effect_rem_table_item(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_table_item_data *d = (void*)e->data;
	if (d->item == ENT_NULL || entity_has_effect(d->item, EF_B_NONEXISTENT)) return 1;
	return 0;
}
void effect_scan_s_bump(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_s_bump_data *d = (void*)e->data;
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->ent = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->ent = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->ent = ENT_NULL; }
	else {d->ent = ENT_NULL;} }
	fread(&d->force, sizeof(int), 1, stream);
}
void effect_dump_s_bump(effect_s *e, FILE *stream) {
	effect_s_bump_data *d = (void*)e->data;
	{ int t; if (d->ent == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->ent) != NULL) {t = entity_get_index(ent_aptr(d->ent));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->ent, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
	fwrite(&d->force, sizeof(int), 1, stream);
}
int effect_rem_s_bump(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_s_bump_data *d = (void*)e->data;
	if (d->ent != ENT_NULL && entity_has_effect(d->ent, EF_B_NONEXISTENT)) d->ent = ENT_NULL;
	return 0;
}
void effect_scan_s_dmg(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_s_dmg_data *d = (void*)e->data;
	fread(&d->type, sizeof(int), 1, stream);
	fread(&d->val, sizeof(int), 1, stream);
}
void effect_dump_s_dmg(effect_s *e, FILE *stream) {
	effect_s_dmg_data *d = (void*)e->data;
	fwrite(&d->type, sizeof(int), 1, stream);
	fwrite(&d->val, sizeof(int), 1, stream);
}
void effect_scan_rotation(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_rotation_data *d = (void*)e->data;
	fread(&d->type, sizeof(rotation_type), 1, stream);
	fread(&d->rotation, sizeof(int), 1, stream);
}
void effect_dump_rotation(effect_s *e, FILE *stream) {
	effect_rotation_data *d = (void*)e->data;
	fwrite(&d->type, sizeof(rotation_type), 1, stream);
	fwrite(&d->rotation, sizeof(int), 1, stream);
}
void effect_scan_a_pressure_plate(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_a_pressure_plate_data *d = (void*)e->data;
	fread(&d->thresold, sizeof(int), 1, stream);
}
void effect_dump_a_pressure_plate(effect_s *e, FILE *stream) {
	effect_a_pressure_plate_data *d = (void*)e->data;
	fwrite(&d->thresold, sizeof(int), 1, stream);
}
void effect_scan_m_grab(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_m_grab_data *d = (void*)e->data;
	fread(&d->eff_tag, sizeof(uint32_t), 1, stream);
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->ent = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->ent = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->ent = ENT_NULL; }
	else {d->ent = ENT_NULL;} }
	fread(&d->mat_tag, sizeof(uint32_t), 1, stream);
}
void effect_dump_m_grab(effect_s *e, FILE *stream) {
	effect_m_grab_data *d = (void*)e->data;
	fwrite(&d->eff_tag, sizeof(uint32_t), 1, stream);
	{ int t; if (d->ent == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->ent) != NULL) {t = entity_get_index(ent_aptr(d->ent));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->ent, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
	fwrite(&d->mat_tag, sizeof(uint32_t), 1, stream);
}
int effect_rem_m_grab(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_m_grab_data *d = (void*)e->data;
	if (d->ent == ENT_NULL || entity_has_effect(d->ent, EF_B_NONEXISTENT)) return 1;
	return 0;
}
void effect_scan_m_drop(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_m_drop_data *d = (void*)e->data;
	fread(&d->eff_tag, sizeof(uint32_t), 1, stream);
}
void effect_dump_m_drop(effect_s *e, FILE *stream) {
	effect_m_drop_data *d = (void*)e->data;
	fwrite(&d->eff_tag, sizeof(uint32_t), 1, stream);
}
void effect_scan_m_put(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_m_put_data *d = (void*)e->data;
	fread(&d->eff_tag, sizeof(uint32_t), 1, stream);
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->where = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->where = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->where = ENT_NULL; }
	else {d->where = ENT_NULL;} }
}
void effect_dump_m_put(effect_s *e, FILE *stream) {
	effect_m_put_data *d = (void*)e->data;
	fwrite(&d->eff_tag, sizeof(uint32_t), 1, stream);
	{ int t; if (d->where == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->where) != NULL) {t = entity_get_index(ent_aptr(d->where));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->where, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
}
int effect_rem_m_put(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_m_put_data *d = (void*)e->data;
	if (d->where == ENT_NULL || entity_has_effect(d->where, EF_B_NONEXISTENT)) return 1;
	return 0;
}
void effect_scan_m_throw(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_m_throw_data *d = (void*)e->data;
	fread(&d->eff_tag, sizeof(uint32_t), 1, stream);
	fread(&d->x, sizeof(int), 1, stream);
	fread(&d->y, sizeof(int), 1, stream);
	fread(&d->z, sizeof(int), 1, stream);
	fread(&d->speed, sizeof(int), 1, stream);
}
void effect_dump_m_throw(effect_s *e, FILE *stream) {
	effect_m_throw_data *d = (void*)e->data;
	fwrite(&d->eff_tag, sizeof(uint32_t), 1, stream);
	fwrite(&d->x, sizeof(int), 1, stream);
	fwrite(&d->y, sizeof(int), 1, stream);
	fwrite(&d->z, sizeof(int), 1, stream);
	fwrite(&d->speed, sizeof(int), 1, stream);
}
void effect_scan_r_bottle_dispenser(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_r_bottle_dispenser_data *d = (void*)e->data;
	fread(&d->mat_tag, sizeof(uint32_t), 1, stream);
}
void effect_dump_r_bottle_dispenser(effect_s *e, FILE *stream) {
	effect_r_bottle_dispenser_data *d = (void*)e->data;
	fwrite(&d->mat_tag, sizeof(uint32_t), 1, stream);
}
void effect_scan_stats(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_stats_data *d = (void*)e->data;
	fread(&d->str, sizeof(int), 1, stream);
	fread(&d->dex, sizeof(int), 1, stream);
	fread(&d->spd, sizeof(int), 1, stream);
}
void effect_dump_stats(effect_s *e, FILE *stream) {
	effect_stats_data *d = (void*)e->data;
	fwrite(&d->str, sizeof(int), 1, stream);
	fwrite(&d->dex, sizeof(int), 1, stream);
	fwrite(&d->spd, sizeof(int), 1, stream);
}
void effect_scan_ph_liquid(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_ph_liquid_data *d = (void*)e->data;
	fread(&d->amount, sizeof(int), 1, stream);
	fread(&d->type, sizeof(int), 1, stream);
}
void effect_dump_ph_liquid(effect_s *e, FILE *stream) {
	effect_ph_liquid_data *d = (void*)e->data;
	fwrite(&d->amount, sizeof(int), 1, stream);
	fwrite(&d->type, sizeof(int), 1, stream);
}
void effect_scan_container(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_container_data *d = (void*)e->data;
	fread(&d->cont_mask, sizeof(uint32_t), 1, stream);
	fread(&d->min_size, sizeof(int), 1, stream);
	fread(&d->capacity, sizeof(int), 1, stream);
}
void effect_dump_container(effect_s *e, FILE *stream) {
	effect_container_data *d = (void*)e->data;
	fwrite(&d->cont_mask, sizeof(uint32_t), 1, stream);
	fwrite(&d->min_size, sizeof(int), 1, stream);
	fwrite(&d->capacity, sizeof(int), 1, stream);
}
void effect_scan_container_item(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_container_item_data *d = (void*)e->data;
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->item = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->item = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->item = ENT_NULL; }
	else {d->item = ENT_NULL;} }
}
void effect_dump_container_item(effect_s *e, FILE *stream) {
	effect_container_item_data *d = (void*)e->data;
	{ int t; if (d->item == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->item) != NULL) {t = entity_get_index(ent_aptr(d->item));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->item, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
}
int effect_rem_container_item(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_container_item_data *d = (void*)e->data;
	if (d->item == ENT_NULL || entity_has_effect(d->item, EF_B_NONEXISTENT)) return 1;
	return 0;
}
void effect_scan_wet(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_wet_data *d = (void*)e->data;
	fread(&d->type, sizeof(int), 1, stream);
	fread(&d->amount, sizeof(int), 1, stream);
}
void effect_dump_wet(effect_s *e, FILE *stream) {
	effect_wet_data *d = (void*)e->data;
	fwrite(&d->type, sizeof(int), 1, stream);
	fwrite(&d->amount, sizeof(int), 1, stream);
}
void effect_scan_m_fill_cont(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_m_fill_cont_data *d = (void*)e->data;
	fread(&d->hand_tag, sizeof(uint32_t), 1, stream);
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->target = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->target = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->target = ENT_NULL; }
	else {d->target = ENT_NULL;} }
}
void effect_dump_m_fill_cont(effect_s *e, FILE *stream) {
	effect_m_fill_cont_data *d = (void*)e->data;
	fwrite(&d->hand_tag, sizeof(uint32_t), 1, stream);
	{ int t; if (d->target == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->target) != NULL) {t = entity_get_index(ent_aptr(d->target));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->target, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
}
int effect_rem_m_fill_cont(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_m_fill_cont_data *d = (void*)e->data;
	if (d->target == ENT_NULL || entity_has_effect(d->target, EF_B_NONEXISTENT)) return 1;
	return 0;
}
void effect_scan_m_empty_cont(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_m_empty_cont_data *d = (void*)e->data;
	fread(&d->hand_tag, sizeof(uint32_t), 1, stream);
}
void effect_dump_m_empty_cont(effect_s *e, FILE *stream) {
	effect_m_empty_cont_data *d = (void*)e->data;
	fwrite(&d->hand_tag, sizeof(uint32_t), 1, stream);
}
void effect_scan_m_press_button(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_m_press_button_data *d = (void*)e->data;
	fread(&d->hand_tag, sizeof(uint32_t), 1, stream);
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->target = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->target = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->target = ENT_NULL; }
	else {d->target = ENT_NULL;} }
	fread(&d->mat_tag, sizeof(uint32_t), 1, stream);
}
void effect_dump_m_press_button(effect_s *e, FILE *stream) {
	effect_m_press_button_data *d = (void*)e->data;
	fwrite(&d->hand_tag, sizeof(uint32_t), 1, stream);
	{ int t; if (d->target == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->target) != NULL) {t = entity_get_index(ent_aptr(d->target));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->target, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
	fwrite(&d->mat_tag, sizeof(uint32_t), 1, stream);
}
int effect_rem_m_press_button(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_m_press_button_data *d = (void*)e->data;
	if (d->target == ENT_NULL || entity_has_effect(d->target, EF_B_NONEXISTENT)) return 1;
	return 0;
}
void effect_scan_s_press_button(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_s_press_button_data *d = (void*)e->data;
	fread(&d->mat_tag, sizeof(uint32_t), 1, stream);
}
void effect_dump_s_press_button(effect_s *e, FILE *stream) {
	effect_s_press_button_data *d = (void*)e->data;
	fwrite(&d->mat_tag, sizeof(uint32_t), 1, stream);
}
void effect_scan_m_open_door(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_m_open_door_data *d = (void*)e->data;
	fread(&d->dir, sizeof(int), 1, stream);
	fread(&d->hand_tag, sizeof(uint32_t), 1, stream);
	{ int t; fread(&t, sizeof(int), 1, stream); if (t != -1 && t < n_ent) {d->target = ent_sptr(a_ent[t]);}
	else if (t != -1 && (t & STORED_CPTR_BIT)) { unsigned sec_nr = (t ^ STORED_CPTR_BIT) >> 9, co = t & 0x1FF;
		if (sec_nr <= (unsigned)n_sec) d->target = ent_cptr(a_sec[sec_nr], co >> 6, (co >> 3) & 7, co & 7);
		else d->target = ENT_NULL; }
	else {d->target = ENT_NULL;} }
}
void effect_dump_m_open_door(effect_s *e, FILE *stream) {
	effect_m_open_door_data *d = (void*)e->data;
	fwrite(&d->dir, sizeof(int), 1, stream);
	fwrite(&d->hand_tag, sizeof(uint32_t), 1, stream);
	{ int t; if (d->target == ENT_NULL) {t = -1;}
	else if (ent_aptr(d->target) != NULL) {t = entity_get_index(ent_aptr(d->target));}
	else { sector_s *sec; int x, y, z; if ((sec = ent_acptr(d->target, &x, &y, &z)) != NULL) {t = STORED_CPTR_BIT | (sec->stored_id << 9) | (x << 6) | (y << 3) | z;}	else {fprintf(stderr, "bad bad bad\n"); t = -1;} }
	fwrite(&t, sizeof(int), 1, stream); }
}
int effect_rem_m_open_door(struct entity_s *s, effect_s *e) {
	(void)s; (void)e;
	effect_m_open_door_data *d = (void*)e->data;
	if (d->target == ENT_NULL || entity_has_effect(d->target, EF_B_NONEXISTENT)) return 1;
	return 0;
}
void effect_scan_door(effect_s *e, int n_ent, entity_s **a_ent, int n_sec, sector_s **a_sec, FILE *stream) {
	(void)n_ent; (void)a_ent; (void)n_sec; (void)a_sec;
	effect_door_data *d = (void*)e->data;
	fread(&d->opened, sizeof(int), 1, stream);
}
void effect_dump_door(effect_s *e, FILE *stream) {
	effect_door_data *d = (void*)e->data;
	fwrite(&d->opened, sizeof(int), 1, stream);
}

int effect_data_size[] = {
	[EF_B_NONEXISTENT] = 0,
	[EF_B_INDEX] = sizeof(effect_b_index_data),
	[EF_PH_BLOCK] = sizeof(effect_ph_block_data),
	[EF_PH_ITEM] = sizeof(effect_ph_item_data),
	[EF_FALLING] = 0,
	[EF_TRACER] = sizeof(effect_tracer_data),
	[EF_BLOCK_MOVE] = sizeof(effect_block_move_data),
	[EF_STAIR_MOVE] = sizeof(effect_stair_move_data),
	[EF_RENDER] = sizeof(effect_render_data),
	[EF_NOPHYSICS] = 0,
	[EF_LIMB_SLOT] = sizeof(effect_limb_slot_data),
	[EF_LIMB_HAND] = sizeof(effect_limb_hand_data),
	[EF_LIMB_LEG] = 0,
	[EF_MATERIAL] = sizeof(effect_material_data),
	[EF_AIM] = sizeof(effect_aim_data),
	[EF_ATTACK] = sizeof(effect_attack_data),
	[EF_TABLE] = 0,
	[EF_TABLE_ITEM] = sizeof(effect_table_item_data),
	[EF_FIRE] = 0,
	[EF_S_BUMP] = sizeof(effect_s_bump_data),
	[EF_S_DMG] = sizeof(effect_s_dmg_data),
	[EF_ROTATION] = sizeof(effect_rotation_data),
	[EF_A_PRESSURE_PLATE] = sizeof(effect_a_pressure_plate_data),
	[EF_A_CIRCLE_MOVE] = 0,
	[EF_M_GRAB] = sizeof(effect_m_grab_data),
	[EF_M_DROP] = sizeof(effect_m_drop_data),
	[EF_M_PUT] = sizeof(effect_m_put_data),
	[EF_M_THROW] = sizeof(effect_m_throw_data),
	[EF_R_BOTTLE_DISPENSER] = sizeof(effect_r_bottle_dispenser_data),
	[EF_STATS] = sizeof(effect_stats_data),
	[EF_PH_LIQUID] = sizeof(effect_ph_liquid_data),
	[EF_CONTAINER] = sizeof(effect_container_data),
	[EF_CONTAINER_ITEM] = sizeof(effect_container_item_data),
	[EF_WET] = sizeof(effect_wet_data),
	[EF_M_FILL_CONT] = sizeof(effect_m_fill_cont_data),
	[EF_M_EMPTY_CONT] = sizeof(effect_m_empty_cont_data),
	[EF_M_PRESS_BUTTON] = sizeof(effect_m_press_button_data),
	[EF_S_PRESS_BUTTON] = sizeof(effect_s_press_button_data),
	[EF_M_OPEN_DOOR] = sizeof(effect_m_open_door_data),
	[EF_DOOR] = sizeof(effect_door_data),
};

effect_dump_t effect_dump_functions[] = {
	[EF_B_NONEXISTENT] = NULL,
	[EF_B_INDEX] = effect_dump_b_index,
	[EF_PH_BLOCK] = effect_dump_ph_block,
	[EF_PH_ITEM] = effect_dump_ph_item,
	[EF_FALLING] = NULL,
	[EF_TRACER] = effect_dump_tracer,
	[EF_BLOCK_MOVE] = effect_dump_block_move,
	[EF_STAIR_MOVE] = effect_dump_stair_move,
	[EF_RENDER] = effect_dump_render,
	[EF_NOPHYSICS] = NULL,
	[EF_LIMB_SLOT] = effect_dump_limb_slot,
	[EF_LIMB_HAND] = effect_dump_limb_hand,
	[EF_LIMB_LEG] = NULL,
	[EF_MATERIAL] = effect_dump_material,
	[EF_AIM] = effect_dump_aim,
	[EF_ATTACK] = effect_dump_attack,
	[EF_TABLE] = NULL,
	[EF_TABLE_ITEM] = effect_dump_table_item,
	[EF_FIRE] = NULL,
	[EF_S_BUMP] = effect_dump_s_bump,
	[EF_S_DMG] = effect_dump_s_dmg,
	[EF_ROTATION] = effect_dump_rotation,
	[EF_A_PRESSURE_PLATE] = effect_dump_a_pressure_plate,
	[EF_A_CIRCLE_MOVE] = NULL,
	[EF_M_GRAB] = effect_dump_m_grab,
	[EF_M_DROP] = effect_dump_m_drop,
	[EF_M_PUT] = effect_dump_m_put,
	[EF_M_THROW] = effect_dump_m_throw,
	[EF_R_BOTTLE_DISPENSER] = effect_dump_r_bottle_dispenser,
	[EF_STATS] = effect_dump_stats,
	[EF_PH_LIQUID] = effect_dump_ph_liquid,
	[EF_CONTAINER] = effect_dump_container,
	[EF_CONTAINER_ITEM] = effect_dump_container_item,
	[EF_WET] = effect_dump_wet,
	[EF_M_FILL_CONT] = effect_dump_m_fill_cont,
	[EF_M_EMPTY_CONT] = effect_dump_m_empty_cont,
	[EF_M_PRESS_BUTTON] = effect_dump_m_press_button,
	[EF_S_PRESS_BUTTON] = effect_dump_s_press_button,
	[EF_M_OPEN_DOOR] = effect_dump_m_open_door,
	[EF_DOOR] = effect_dump_door,
};

effect_scan_t effect_scan_functions[] = {
	[EF_B_NONEXISTENT] = NULL,
	[EF_B_INDEX] = effect_scan_b_index,
	[EF_PH_BLOCK] = effect_scan_ph_block,
	[EF_PH_ITEM] = effect_scan_ph_item,
	[EF_FALLING] = NULL,
	[EF_TRACER] = effect_scan_tracer,
	[EF_BLOCK_MOVE] = effect_scan_block_move,
	[EF_STAIR_MOVE] = effect_scan_stair_move,
	[EF_RENDER] = effect_scan_render,
	[EF_NOPHYSICS] = NULL,
	[EF_LIMB_SLOT] = effect_scan_limb_slot,
	[EF_LIMB_HAND] = effect_scan_limb_hand,
	[EF_LIMB_LEG] = NULL,
	[EF_MATERIAL] = effect_scan_material,
	[EF_AIM] = effect_scan_aim,
	[EF_ATTACK] = effect_scan_attack,
	[EF_TABLE] = NULL,
	[EF_TABLE_ITEM] = effect_scan_table_item,
	[EF_FIRE] = NULL,
	[EF_S_BUMP] = effect_scan_s_bump,
	[EF_S_DMG] = effect_scan_s_dmg,
	[EF_ROTATION] = effect_scan_rotation,
	[EF_A_PRESSURE_PLATE] = effect_scan_a_pressure_plate,
	[EF_A_CIRCLE_MOVE] = NULL,
	[EF_M_GRAB] = effect_scan_m_grab,
	[EF_M_DROP] = effect_scan_m_drop,
	[EF_M_PUT] = effect_scan_m_put,
	[EF_M_THROW] = effect_scan_m_throw,
	[EF_R_BOTTLE_DISPENSER] = effect_scan_r_bottle_dispenser,
	[EF_STATS] = effect_scan_stats,
	[EF_PH_LIQUID] = effect_scan_ph_liquid,
	[EF_CONTAINER] = effect_scan_container,
	[EF_CONTAINER_ITEM] = effect_scan_container_item,
	[EF_WET] = effect_scan_wet,
	[EF_M_FILL_CONT] = effect_scan_m_fill_cont,
	[EF_M_EMPTY_CONT] = effect_scan_m_empty_cont,
	[EF_M_PRESS_BUTTON] = effect_scan_m_press_button,
	[EF_S_PRESS_BUTTON] = effect_scan_s_press_button,
	[EF_M_OPEN_DOOR] = effect_scan_m_open_door,
	[EF_DOOR] = effect_scan_door,
};

effect_rem_t effect_rem_functions[] = {
	[EF_B_NONEXISTENT] = NULL,
	[EF_B_INDEX] = NULL,
	[EF_PH_BLOCK] = NULL,
	[EF_PH_ITEM] = effect_rem_ph_item,
	[EF_FALLING] = NULL,
	[EF_TRACER] = NULL,
	[EF_BLOCK_MOVE] = NULL,
	[EF_STAIR_MOVE] = NULL,
	[EF_RENDER] = NULL,
	[EF_NOPHYSICS] = NULL,
	[EF_LIMB_SLOT] = effect_rem_limb_slot,
	[EF_LIMB_HAND] = effect_rem_limb_hand,
	[EF_LIMB_LEG] = NULL,
	[EF_MATERIAL] = NULL,
	[EF_AIM] = effect_rem_aim,
	[EF_ATTACK] = effect_rem_attack,
	[EF_TABLE] = NULL,
	[EF_TABLE_ITEM] = effect_rem_table_item,
	[EF_FIRE] = NULL,
	[EF_S_BUMP] = effect_rem_s_bump,
	[EF_S_DMG] = NULL,
	[EF_ROTATION] = NULL,
	[EF_A_PRESSURE_PLATE] = NULL,
	[EF_A_CIRCLE_MOVE] = NULL,
	[EF_M_GRAB] = effect_rem_m_grab,
	[EF_M_DROP] = NULL,
	[EF_M_PUT] = effect_rem_m_put,
	[EF_M_THROW] = NULL,
	[EF_R_BOTTLE_DISPENSER] = NULL,
	[EF_STATS] = NULL,
	[EF_PH_LIQUID] = NULL,
	[EF_CONTAINER] = NULL,
	[EF_CONTAINER_ITEM] = effect_rem_container_item,
	[EF_WET] = NULL,
	[EF_M_FILL_CONT] = effect_rem_m_fill_cont,
	[EF_M_EMPTY_CONT] = NULL,
	[EF_M_PRESS_BUTTON] = effect_rem_m_press_button,
	[EF_S_PRESS_BUTTON] = NULL,
	[EF_M_OPEN_DOOR] = effect_rem_m_open_door,
	[EF_DOOR] = NULL,
};
